library(minfi)
args = commandArgs(trailingOnly = T)
analysis_package <- "IlluminaHumanMethylationEPICmanifest"
library(analysis_package, character.only = TRUE)
annotation_package <- "IlluminaHumanMethylationEPICanno.ilm10b4.hg19"

#' Get Model Matrix
#' @param metadata A data frame containing the meta data.
#' @return The design matrix created from the specified grouping variable and covariates.
get_model_matrix <- function(metadata)
{
    # create the model formula
    model_string = as.formula(paste("~", "conditions"))
    
    # Create design matrix
    design <- model.matrix(model_string, data = metadata)
    return(design)
}

#' Get M-values
#' @param metadata A data frame containing the meta data, including the paths to the IDAT files.
#' @param opts A list containing options for preprocessing the IDAT files. The list should include:
#' @return A matrix of M-values obtained after preprocessing the IDAT files.
#' @return A matrix of M-values obtained after preprocessing the IDAT files.
#' default preprocessing type set is preprocessIllumina
get_m_values <- function(metadata, opts) {
    # Read IDAT files
    RGset <- read.metharray(metadata$path, extended = TRUE)
    preprocess_method = opts$pp
    if (preprocess_method == "preprocessSWAN") {
        Mset <- preprocessSWAN(RGset)
    } else if (preprocess_method == "preprocessQuantile") {
        Mset <- preprocessQuantile(RGset)
    } else if (preprocess_method == "preprocessNoob") {
        Mset <- preprocessNoob(RGset)
    } else if (preprocess_method == "preprocessRaw") {
        Mset <- preprocessRaw(RGset)
    } else {
        Mset <- preprocessIllumina(RGset)
    } 
    # get m_ values
    m_values <- getM(Mset)
    return(m_values)
}

#' Get Updated Metadata
#' @param metadata A data frame containing the meta data, converting the group factor to autogenerated
#' @return A updated metadata
get_updated_metadata <- function(metadata)
{
    # Convert 'Group' to factor with automatically generated levels
    metadata$conditions <- factor(metadata$conditions, 
                                    levels = unique(metadata$conditions), 
                                    labels = paste0("conditions", seq_along(unique(metadata$conditions))))
    return (metadata);
}

#' Get Coefficient Name from Model Fit
#' Retrieves the name of the first coefficient from the model fit object `fit2`.
#' This is typically used to determine the reference group or baseline for comparison
#' @param coefficients Unused parameter (included for compatibility or future use). 
#'                     Currently not used within the function.
#' @return A character string representing the name of the first coefficient 
#'         from `fit2$coefficients`.
get_coeff <- function(coefficients) 
{
    coeffArray <- colnames(fit2$coefficients)
    return (coeffArray[1])
}

#' Refactor Results Table for Output
#' This function selects and rounds essential columns (`logFC`, `adj.P.Val`)
#' from the input results table. It is typically used after differential analysis
#' to prepare results for display or downstream processing.
#' @param results A data frame containing the results of a differential analysis,
#'                including columns `logFC` (log fold change) and `adj.P.Val`
#'                (adjusted p-value).
#' @return A data frame containing only the selected columns (`logFC`, `adj.P.Val`),
#'         with values rounded to six decimal places.
get_refactored_result <- function(results)
{
    colnames(results)[colnames(results) == "X"] <- "CpgId"
    # Select only essential columns
    essential_cols <- c("CpgId", "logFC", "adj.P.Val")
    print(results)
    print(essential_cols)
    results <- results[, essential_cols, drop = FALSE]
    results$adj.P.Val <- round(results$adj.P.Val, 6)
    results$logFC <- round(results$logFC, 6)
    
    return (results);
}

#' Get annotation
#' This function runs annotation for differential analysis results
#' @param results A data frame containing the results of a differential analysis,
#' @return annotated results with additional information from the annotation package.
#' Steps:
#' 1. Load annotation package
#' 2. Merge DMA results with annotation
#' 3. Select essential columns to avoid processing of large file
#' 4. Enhancer is specific to 450/850K, so referring dynamically without specific types
#' 5. Return the annotated results
get_annotation_result <- function(results)
{
    anno <- getAnnotation(annotation_package)
    results_annotated <- merge(results, anno, by.x = "CpgId", by.y = "Name", all.x = TRUE)
    essential_cols <- c("CpgId", "logFC", "adj.P.Val","UCSC_RefGene_Name","Regulatory_Feature_Name")
    enhancer_cols <- grep("Enhancer", names(results_annotated), value = TRUE, ignore.case = TRUE)
    all_cols <- unique(c(essential_cols, enhancer_cols))
    results_annotated <- results_annotated[, all_cols, drop = FALSE]
    return(results_annotated);
}

#' compress result
#' This function compresses the results file into a gzipped format.
#' @param results A data frame containing the results to be compressed.
#' @param gzfile_path The path where the gzipped file will be saved.
#' @return None
get_compressed_result <- function(results, gzfile_path) {
    gz_con <- gzfile(gzfile_path, "wt")
    write.csv(results, gz_con, row.names = TRUE)
    close(gz_con)
}